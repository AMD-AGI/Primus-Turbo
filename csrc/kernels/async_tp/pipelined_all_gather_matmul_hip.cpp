// !!! This is a file automatically generated by hipify!!!
#include "all_gather_matmul.h"
#include "helper.hpp"
#include "hip/hip_runtime.h"
#include "primus_turbo/macros.h"
#include <optional>

namespace primus_turbo::async_tp {

void Barrier(uint32_t **barrier, int rank, int world_size, hipStream_t stream) {
    hipLaunchKernelGGL((barrier_kernel), dim3(1), dim3(64), 0, stream, barrier, 0, rank, world_size,
                       0);
}

void PipelinedCopySendWithSignals(std::vector<std::vector<void *>> &dst_ptrs,
                                  std::vector<void *> src_ptrs, std::vector<size_t> &sizes,
                                  std::vector<uint32_t *> signal_pads, int rank, int world_size,
                                  hipMemcpyKind cp_type, std::vector<hipStream_t> &comm_streams,
                                  hipEvent_t comm_event) {
    int dst_offset = -1;
    int num_stream = comm_streams.size();
    for (int dst_rank = 0, idx = 0; dst_rank < world_size; ++dst_rank) {
        if (dst_rank == rank)
            continue;
        dst_offset = rank < dst_rank ? rank : rank - 1;

        for (size_t i = 0; i < sizes.size(); ++i) {
            PRIMUS_TURBO_CHECK_HIP(
                hipMemcpyAsync((char *) dst_ptrs[dst_rank][i] + dst_offset * sizes[i], src_ptrs[i],
                               sizes[i], cp_type, comm_streams[idx % num_stream]));
        }

        // PRIMUS_TURBO_CHECK_HIP(
        //     hipMemcpyAsync(
        //         signal_pads[dst_rank] + rank * 4,
        //         one.data_ptr(),
        //         one.nbytes,
        //         comm_kind_type,
        //         ag_stream.cuda_stream,
        //     )
        // )

        PRIMUS_TURBO_CHECK_HIP(hipEventRecord(comm_event, comm_streams[idx % num_stream]));
        ++idx;
    }
}

auto hipDataTypeToSize(hipDataType type) {
    switch (type) {
    case hipDataType::HIP_C_8I:
        return 8;

    default:
        return 0;
    }
    return -1;
}

template <typename GemmOp, typename Communicator>
void PipelinedAllGatherGEMM(void *A_shard, hipDataType A_shard_type, std::optional<void *> A_scale,
                            std::optional<hipDataType> A_scale_type, void **weights,
                            hipDataType *weight_types, int num_weights, int m, int k, int *ns,
                            int num_splits, std::vector<hipStream_t> &comm_streams,
                            hipEvent_t comm_event, Communicator *comm) {

    size_t A_shard_bytes    = m * k * hipDataTypeToSize(A_shard_type);
    size_t request_buf_size = A_shard_bytes;
    if (A_scale.has_value()) {
        request_buf_size += m * hipDataTypeToSize(A_scale_type.value());
    }

    auto symm_mem = SymmetricMemoryManager::Instance().GetSymmMem(request_buf_size, comm);

    int  rank             = symm_mem->get_rank();
    int  world_size       = symm_mem->get_world_size();
    auto comm_buffer_ptrs = symm_mem->get_buffer_ptrs();
    auto signal_pads      = symm_mem->get_signal_pad_ptrs();

    std::vector<std::vector<void *>> shard_bufs(world_size);

    for (int i = 0; i < world_size; ++i) {
        shard_bufs[i].push_back(comm_buffer_ptrs[i]);

        if (A_scale.has_value()) {
            shard_bufs[i].push_back((char *) comm_buffer_ptrs[i] + A_shard_bytes);
        }
    }

    std::vector<void *> input_ptrs;
    std::vector<int>    send_sizes;
    input_ptrs.push_back(A_shard);
    send_sizes.push_back(A_shard_bytes);
    if (A_scale.has_value()) {
        input_ptrs.push_back(A_scale.value());
        send_sizes.push_back(m * hipDataTypeToSize(A_scale_type.value()));
    }

    for (int step = 0; step < num_splits; ++step) {
        PipelinedCopySendWithSignals(shard_bufs, input_ptrs, send_sizes, signal_pads, rank,
                                     world_size, hipMemcpyKind::hipMemcpyDeviceToDevice,
                                     comm_streams, comm_event);
    }
}

} // namespace primus_turbo::async_tp
